// routes/auth.js
const express = require('express');
const router = express.Router();
// --- Corrected Paths ---
const User = require('../models/User'); // Assumes models/ is one level up from routes/
const sendEmail = require('../utils/sendEmail'); // Assumes utils/ is one level up from routes/
// --- End Correction ---
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const passport = require('passport');
require('dotenv').config();

// --- POST /api/auth/register ---
// @desc    Register a new user & trigger email verification
router.post('/register', async (req, res) => {
  const { name, email, password } = req.body;

  // Basic Validation
  if (!email || !password) {
    return res.status(400).json({ message: 'Please provide email and password' });
  }
  if (password.length < 6) {
    return res.status(400).json({ message: 'Password must be at least 6 characters' });
  }

  try {
    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'Email already in use.' });
    }

    // Create new user instance
    const user = new User({
      name,
      email,
      password, // Password hashing happens in pre-save hook
    });

    // Save user initially (gets _id, runs password hash hook)
    const savedUser = await user.save();

    // --- Generate Verification Token ---
    // This method sets the hashed token and expiry on the 'savedUser' instance IN MEMORY
    const verificationToken = savedUser.getEmailVerificationToken();
    const hashedTokenToSave = savedUser.emailVerificationToken; // Get the hash generated by the method
    const expiryDateToSave = savedUser.emailVerificationTokenExpires; // Get the expiry generated by the method

    // --- FIX: Use findByIdAndUpdate instead of second save ---
    if (!hashedTokenToSave || !expiryDateToSave) {
        // Safety check - should not happen if getEmailVerificationToken works
        throw new Error('Failed to generate verification token fields.');
    }
    await User.findByIdAndUpdate(savedUser._id, {
        emailVerificationToken: hashedTokenToSave,
        emailVerificationTokenExpires: expiryDateToSave
    });

    // --- Send Verification Email ---
    const verifyUrl = `${process.env.FRONTEND_URL}/verify-email/${verificationToken}`; // Use RAW token in URL
    const message = `
      <h1>Verify Your Email Address for Novel Scribe</h1>
      <p>Thank you for registering! Please click the link below to verify your email address:</p>
      <p><a href="${verifyUrl}" clicktracking=off>${verifyUrl}</a></p>
      <p>This link will expire in 15 minutes.</p>
      <p>If you didn't request this, please ignore this email.</p>
    `;

    try {
      await sendEmail({
        to: savedUser.email, // Use email from saved user
        subject: 'Novel Scribe - Email Verification',
        text: `Please verify your email by clicking this link: ${verifyUrl} (Link expires in 15 minutes)`,
        html: message,
      });

      res.status(201).json({
        message: 'Registration successful. Please check your email to verify your account.',
      });

    } catch (emailError) {
      console.error('Email sending error after registration:', emailError);
      // Consider user cleanup logic here for production
      return res.status(500).json({ message: 'User registered, but verification email could not be sent. Please contact support.' });
    }

  } catch (error) {
    console.error('Registration Error:', error);
    if (error.code === 11000) {
      return res.status(400).json({ message: 'Email already exists' });
    }
    // Log the actual error for debugging Mongoose/DB issues
    console.error("Detailed Registration Error:", error);
    res.status(500).json({ message: 'Server error during registration' });
  }
});

// --- GET /api/auth/verify-email/:token ---
// (This route remains the same as before - it should work if token is saved correctly now)
router.get('/verify-email/:token', async (req, res) => {
    const verificationToken = req.params.token;
    const hashedToken = crypto
        .createHash('sha256')
        .update(verificationToken)
        .digest('hex');
    const currentTime = Date.now();

    try {
        const user = await User.findOne({
            emailVerificationToken: hashedToken,
            emailVerificationTokenExpires: { $gt: currentTime } // Use variable for clarity
        });

        if (!user) {
            return res.status(400).json({ message: 'Invalid or expired verification token.' });
        }

        user.isVerified = true;
        user.emailVerificationToken = undefined;
        user.emailVerificationTokenExpires = undefined;
        await user.save({ validateBeforeSave: false });

        res.status(200).json({ message: 'Email verified successfully. You can now log in.' });

    } catch (error) {
        console.error('Email Verification Error:', error);
        res.status(500).json({ message: 'Server error during email verification.' });
    }
});


// --- POST /api/auth/login ---
// (Remains the same - includes isVerified check and returns isVerified status)
router.post('/login', async (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
     return res.status(400).json({ message: 'Please provide email and password' });
   }

  try {
    const user = await User.findOne({ email }).select('+password +isVerified');

    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    if (!user.isVerified) {
        return res.status(401).json({ message: 'Please verify your email address before logging in.' });
    }

    const isMatch = await user.matchPassword(password);

    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const payload = { userId: user._id };
    const token = jwt.sign(
      payload,
      process.env.JWT_SECRET,
      { expiresIn: '30d' }
    );

    res.status(200).json({
      message: 'Login successful',
      token: token,
      userId: user._id,
      name: user.name,
      email: user.email,
      isVerified: user.isVerified // Include isVerified status
    });

  } catch (error) {
    console.error('Login Error:', error);
    res.status(500).json({ message: 'Server error during login' });
  }
});


// --- GET /api/auth/google ---
// (Remains the same)
router.get('/google', passport.authenticate('google', {
    scope: ['profile', 'email'],
    session: false
}));

// --- GET /api/auth/google/callback ---
// (Remains the same - redirects to frontend with token/user info)
router.get('/google/callback',
    passport.authenticate('google', {
        failureRedirect: `${process.env.FRONTEND_URL}/login?error=google-auth-failed`,
        session: false
    }),
    (req, res) => {
        if (!req.user) {
           return res.redirect(`${process.env.FRONTEND_URL}/login?error=google-auth-error`);
        }
        const payload = { userId: req.user._id };
        const token = jwt.sign(
            payload,
            process.env.JWT_SECRET,
            { expiresIn: '30d' }
        );
        const nameParam = encodeURIComponent(req.user.name || '');
        const emailParam = encodeURIComponent(req.user.email || '');
        const redirectUrl = `${process.env.FRONTEND_URL}/auth/callback?token=${token}&userId=${req.user._id}&name=${nameParam}&email=${emailParam}&isVerified=true`;
        console.log(`Redirecting Google user ${req.user.email} to frontend callback`);
        res.redirect(redirectUrl);
    }
);

// --- Add Forgot Password Route ---
// POST /api/auth/forgotpassword
// @desc    Request password reset link
router.post('/forgotpassword', async (req, res) => {
    const { email } = req.body;

    if (!email) {
        return res.status(400).json({ message: 'Please provide an email address.' });
    }

    try {
        const user = await User.findOne({ email });

        // IMPORTANT: Always send a generic success response EVEN IF USER NOT FOUND
        // This prevents attackers from discovering registered email addresses.
        if (user) {
            // Generate reset token (raw token returned, hash saved to user instance)
            const resetToken = user.getPasswordResetToken();

            // Save the hashed token and expiry date to the database
            // Use findByIdAndUpdate for robustness
            await User.findByIdAndUpdate(user._id, {
                passwordResetToken: user.passwordResetToken, // The hash set by the method
                passwordResetTokenExpires: user.passwordResetTokenExpires
            });

            // Create reset URL (points to frontend page)
            const resetUrl = `${process.env.FRONTEND_URL}/reset-password/${resetToken}`; // Send RAW token

            const message = `
              <h1>Reset Your Password for Novel Scribe</h1>
              <p>You requested a password reset. Please click the link below to set a new password:</p>
              <p><a href="${resetUrl}" clicktracking=off>${resetUrl}</a></p>
              <p>This link will expire in 10 minutes.</p>
              <p>If you didn't request this, please ignore this email.</p>
            `;

            try {
                await sendEmail({
                    to: user.email,
                    subject: 'Novel Scribe - Password Reset Request',
                    text: `Click this link to reset your password (expires in 10 mins): ${resetUrl}`,
                    html: message,
                });
            } catch (emailError) {
                console.error('Password Reset Email sending error:', emailError);
                // Clear potentially saved token if email fails? Or just let it expire.
                // For now, we still send the generic success response below.
            }
        } else {
            console.log(`Password reset requested for non-existent email: ${email}`);
        }

        // Send generic success response regardless of user existence
        res.status(200).json({ message: 'If an account with that email exists, a password reset link has been sent.' });

    } catch (error) {
        console.error('Forgot Password Error:', error);
        // Still send generic message even on server error for security
        res.status(200).json({ message: 'If an account with that email exists, a password reset link has been sent.' });
    }
});

// --- Add Reset Password Route ---
// PUT /api/auth/resetpassword/:token
// @desc    Reset password using token
router.put('/resetpassword/:token', async (req, res) => {
    const resetToken = req.params.token;
    const { password } = req.body;

    // Basic validation for new password
    if (!password || password.length < 6) {
        return res.status(400).json({ message: 'Password must be at least 6 characters long.' });
    }

    // Hash the token from the URL parameter to match the stored hash
    const hashedToken = crypto
        .createHash('sha256')
        .update(resetToken)
        .digest('hex');

    try {
        // Find user by the HASHED token & check expiration
        const user = await User.findOne({
            passwordResetToken: hashedToken,
            passwordResetTokenExpires: { $gt: Date.now() }
        });

        if (!user) {
            return res.status(400).json({ message: 'Invalid or expired password reset token.' });
        }

        // Token is valid, set the new password
        // The pre-save hook in the User model will automatically hash it
        user.password = password;

        // Clear the reset token fields
        user.passwordResetToken = undefined;
        user.passwordResetTokenExpires = undefined;

        // Save the user with the new password and cleared tokens
        // Use validateBeforeSave: true here, or just save(), as password validation should run
        await user.save();

        // Optionally: Send confirmation email?
        // Optionally: Log the user in by sending back a JWT? For now, just confirm success.

        res.status(200).json({ message: 'Password reset successful. You can now log in with your new password.' });

    } catch (error) {
        console.error('Reset Password Error:', error);
        res.status(500).json({ message: 'Server error during password reset.' });
    }
});
// --- End Added Routes ---


module.exports = router;